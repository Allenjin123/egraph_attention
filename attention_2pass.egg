(datatype Tensor
  (CreateTensor i64 i64 String)
  ; Map operations (element-wise, no reduction)
  (M_mul_em1m0p Tensor Tensor)
  (M_sub_m1m0p Tensor Tensor)
  (M_exp_m1m0p Tensor)
  (M_sub_m1p Tensor Tensor)
  (M_exp_m1p Tensor)
  (M_mul_m1m0p Tensor Tensor)
  (M_mul_m1p Tensor Tensor)
  (M_div_m1m0p Tensor Tensor)
  (M_mul_fm1m0p Tensor Tensor)
  (M_mul_fmp Tensor Tensor)
  (M_div_fp Tensor Tensor)           ; NEW: [f,p] / [p] -> [f,p]
  ; Reduce operations (no map)
  (R_add_e Tensor)
  (R_max_m0 Tensor)
  (R_max_m1 Tensor)
  (R_add_m0 Tensor)
  (R_add_m1 Tensor)
  (R_add_m Tensor)
  ; Tiling operations
  (T_split_m_m1m0 Tensor i64)
  (T_unsplit_m1m0_m Tensor)
  )

; create tensors
;                    E   P
(let Q (CreateTensor 64 1024 "Q"))   ; Q_{e,p} - NOT tiled
(let K (CreateTensor 64 1024 "K"))   ; K_{e,m}
(let V (CreateTensor 64 1024 "V"))   ; V_{f,m}

; ============================================
; Two-Pass Attention Algorithm (FuseMax Paper)
; ============================================
; Ranks:
;   e (embedding dim for Q/K)
;   f (embedding dim for V)
;   p (sequence length for Q)
;   m (sequence length for K/V) = m1 × m0
;     m1 (tile index, e.g., 0..3 for 4 tiles)
;     m0 (position within tile)
; ============================================
; Pass 1: Tile K only, compute local statistics per tile,
;         build global max from local maxes
; Pass 2: Use global max to correct local statistics,
;         compute output with V, accumulate weighted V
; Post-loop: Normalize accumulated output by global sum
; ============================================

; ===== Pass 1: Tile K only and compute local statistics =====
; Split K into tiles along M dimension (M = M1 × M0)
; BK_{e,m1,m0} = split_m_into_m1m0(K_{e,m})
(let BK (T_split_m_m1m0 K 4))

; Compute BQK from Q and tiled K
; Map multiply: temp_{e,m1,m0,p} = Q_{e,p} * BK_{e,m1,m0}
(let BQK_temp (M_mul_em1m0p Q BK))
; Reduce e: BQK_{m1,m0,p}
(let BQK (R_add_e BQK_temp))

; Compute local max per tile
; LM_{m1,p} = max_{m0}(BQK_{m1,m0,p})
(let LM (R_max_m0 BQK))

; ┌─────────────────────────────────────────────────────────────────┐
; │ CRITICAL DEPENDENCY - FUSION BARRIER                            │
; │ Build global max from local maxes (reduce across tiles m1)      │
; │ GM_p = max_{m1}(LM_{m1,p})                                      │
; │ MUST wait for ALL tiles to compute LM before GM can be computed │
; │ This creates the boundary between Pass 1 and Pass 2!            │
; └─────────────────────────────────────────────────────────────────┘
(let GM (R_max_m1 LM))

; These can fuse with LM computation (same pass)
; Compute local softmax numerator: SLN_{m1,m0,p} = exp(BQK - LM)
(let BQK_shifted (M_sub_m1m0p BQK LM))
(let SLN (M_exp_m1m0p BQK_shifted))

; Compute local softmax denominator: SLD_{m1,p} = sum_{m0}(SLN)
(let SLD (R_add_m0 SLN))

; ===== Pass 2: Correct local statistics using global max =====
; Compute correction factor: PRM_{m1,p} = exp(LM_{m1,p} - GM_p)
(let LM_GM_diff (M_sub_m1p LM GM))
(let PRM (M_exp_m1p LM_GM_diff))

; Correct local numerator: CN_{m1,m0,p} = SLN_{m1,m0,p} * PRM_{m1,p}
(let CN (M_mul_m1m0p SLN PRM))

; Correct local denominator: CD_{m1,p} = SLD_{m1,p} * PRM_{m1,p}
(let CD (M_mul_m1p SLD PRM))

; Compute GLOBAL denominator: GD_p = sum_{m1}(CD_{m1,p})
(let GD (R_add_m1 CD))

; ===== KEY FIX: Multiply V with UNNORMALIZED attention =====
; Untile corrected (but NOT normalized) attention
; A_unnorm_{m,p} = unsplit_m1m0_into_m(CN_{m1,m0,p})
(let A_unnorm (T_unsplit_m1m0_m CN))

; Multiply by V and accumulate (in same pass 2 loop as GD!)
; AV_temp_{f,m,p} = A_unnorm_{m,p} * V_{f,m}
(let AV_temp (M_mul_fmp A_unnorm V))
; AV_acc_{f,p} = sum_m(AV_temp_{f,m,p})
(let AV_acc (R_add_m AV_temp))

; ===== Post-loop: Final normalization =====
; AV_{f,p} = AV_acc_{f,p} / GD_p
; This happens AFTER pass 2 loop - no K/V reload needed!
(let AV (M_div_fp AV_acc GD))

(extract AV)
