(datatype Tensor
  (CreateTensor i64 i64 String)
  ; BQK_{m1,m0,p} = Q_{e,p} * BK_{e,m1,m0}, iterate {e,m1,m0,p}, reduce e
  (M_mul_em1m0p_R_add_e Tensor Tensor)
  ; LM_{m1,p} = max_{m0}(BQK_{m1,m0,p}), iterate {m1,m0,p}, reduce m0
  (M_none_m1m0p_R_max_m0 Tensor)
  ; GM_p = max_{m1}(LM_{m1,p}), iterate {m1,p}, reduce m1
  (M_none_m1p_R_max_m1 Tensor)
  ; SLN_{m1,m0,p} = exp(BQK - LM), iterate {m1,m0,p}, no reduction
  (M_subexp_m1m0p_R_none Tensor Tensor)
  ; SLD_{m1,p} = sum_{m0}(SLN), iterate {m1,m0,p}, reduce m0
  (M_none_m1m0p_R_add_m0 Tensor)
  ; GD_p = sum_{m1}(CD), iterate {m1,p}, reduce m1
  (M_none_m1p_R_add_m1 Tensor)
  ; Element-wise subtract, iterate {m1,p}, no reduction
  (M_sub_m1p_R_none Tensor Tensor)
  ; Element-wise exp, iterate {m1,p}, no reduction
  (M_exp_m1p_R_none Tensor)
  ; Element-wise multiply, iterate {m1,m0,p}, no reduction
  (M_mul_m1m0p_R_none Tensor Tensor)
  ; Element-wise multiply, iterate {m1,p}, no reduction
  (M_mul_m1p_R_none Tensor Tensor)
  ; Element-wise divide, iterate {m1,m0,p}, no reduction
  (M_div_m1m0p_R_none Tensor Tensor)
  ; AV_{f,p} = A_{m,p} * V_{f,m}, iterate {f,m,p}, reduce m
  (M_mul_fmp_R_add_m Tensor Tensor)
  ; Tiling operations - partition M into M1 (tiles) × M0 (within tile)
  ; T_split_m_m1m0: Split m dimension into m1 (tiles) and m0 (within tile)
  (T_split_m_m1m0 Tensor i64)
  ; T_unsplit_m1m0_m: Combine m1 and m0 back into m dimension
  (T_unsplit_m1m0_m Tensor)
  )

; create tensors
;                    E   P
(let Q (CreateTensor 64 1024 "Q"))   ; Q_{e,p} - NOT tiled
(let K (CreateTensor 64 1024 "K"))   ; K_{e,m}
(let V (CreateTensor 64 1024 "V"))   ; V_{f,m}

; ============================================
; Two-Pass Attention Algorithm (FuseMax Paper)
; ============================================
; Ranks:
;   e (embedding dim for Q/K)
;   f (embedding dim for V)
;   p (sequence length for Q)
;   m (sequence length for K/V) = m1 × m0
;     m1 (tile index, e.g., 0..3 for 4 tiles)
;     m0 (position within tile)
; ============================================
; Pass 1: Tile K only, compute local statistics per tile,
;         build global max from local maxes
; Pass 2: Use global max to correct local statistics,
;         untile A, then compute output with V
; ============================================

; ===== Pass 1: Tile K only and compute local statistics =====
; Split K into tiles along M dimension (M = M1 × M0)
; BK_{e,m1,m0} = split_m_into_m1m0(K_{e,m})
(let BK (T_split_m_m1m0 K 4))

; Compute BQK from Q and tiled K
; BQK_{m1,m0,p} = Q_{e,p} * BK_{e,m1,m0}, iterate {e,m1,m0,p}, reduce e
(let BQK (M_mul_em1m0p_R_add_e Q BK))

; Compute local max per tile (reduce over m0 within each tile)
; LM_{m1,p} = max_{m0}(BQK_{m1,m0,p}), iterate {m1,m0,p}, reduce m0
(let LM (M_none_m1m0p_R_max_m0 BQK))

; ┌─────────────────────────────────────────────────────────────────┐
; │ CRITICAL DEPENDENCY - FUSION BARRIER #1                         │
; │ Build global max from local maxes (reduce across tiles m1)      │
; │ GM_p = max_{m1}(LM_{m1,p})                                      │
; │ MUST wait for ALL tiles to compute LM before GM can be computed │
; │ This creates the boundary between Pass 1 and Pass 2!            │
; └─────────────────────────────────────────────────────────────────┘
; GM_p = max_{m1}(LM_{m1,p}), iterate {m1,p}, reduce m1
(let GM (M_none_m1p_R_max_m1 LM))

; These can fuse with LM computation (same pass)
; Compute local softmax numerator per tile: SLN_{m1,m0,p} = exp(BQK - LM)
; Iterate {m1,m0,p}, no reduction
(let SLN (M_subexp_m1m0p_R_none BQK LM))

; Compute local softmax denominator per tile: SLD_{m1,p} = sum_{m0}(SLN)
; Iterate {m1,m0,p}, reduce m0
(let SLD (M_none_m1m0p_R_add_m0 SLN))

; ===== Pass 2: Correct local statistics using global max =====
; Compute correction factor: PRM_{m1,p} = exp(LM_{m1,p} - GM_p)
; First subtract: iterate {m1,p}, no reduction
(let PRM (M_exp_m1p_R_none (M_sub_m1p_R_none LM GM)))

; Correct local numerator: CN_{m1,m0,p} = SLN_{m1,m0,p} * PRM_{m1,p}
; Iterate {m1,m0,p}, no reduction
(let CN (M_mul_m1m0p_R_none SLN PRM))

; Correct local denominator: CD_{m1,p} = SLD_{m1,p} * PRM_{m1,p}
; Iterate {m1,p}, no reduction
(let CD (M_mul_m1p_R_none SLD PRM))

; ┌─────────────────────────────────────────────────────────────────┐
; │ SYNCHRONIZATION POINT (within Pass 2)                           │
; │ Compute GLOBAL denominator: GD_p = sum_{m1}(CD_{m1,p})         │
; │ Need all corrected local denominators before normalizing        │
; │ Note: This is still within Pass 2 (both use GM)                 │
; └─────────────────────────────────────────────────────────────────┘
; Iterate {m1,p}, reduce m1
(let GD (M_none_m1p_R_add_m1 CD))

; Normalize: A_{m1,m0,p} = CN_{m1,m0,p} / GD_p
; Iterate {m1,m0,p}, no reduction
(let A_tiled (M_div_m1m0p_R_none CN GD))

; Untile A: A_{m,p} = unsplit_m1m0_into_m(A_{m1,m0,p})
(let A (T_unsplit_m1m0_m A_tiled))

; Multiply by V: AV_{f,p} = A_{m,p} * V_{f,m}
; Iterate {f,m,p}, reduce m
(let AV (M_mul_fmp_R_add_m A V))

(extract AV)
